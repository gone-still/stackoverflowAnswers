# File        :   main.py (Foreground object segmentation via Grab Cut)
# Version     :   1.0.0
# Description :   Script that segments a foreground object via Grab Cut algorithm.
#                 Answer for: https://stackoverflow.com/questions/67400380/background-removal-from-images-with-opencv-in-android
# Date:       :   Fab 09, 2022
# Author      :   Ricardo Acevedo-Avila (racevedoaa@gmail.com)
# License     :   Creative Commons CC0

# Imports:
import cv2
import numpy as np


# Defines a re-sizable image window:
def showImage(imageName, inputImage):
    cv2.namedWindow(imageName, cv2.WINDOW_NORMAL)
    cv2.imshow(imageName, inputImage)
    cv2.waitKey(0)


# Applies a morpho operation:
def morphoOperation(binaryImage, kernelSize, opIterations, opString):
    # Get the structuring element:
    morphKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernelSize, kernelSize))
    # Perform Operation:
    if opString == "Closing":
        op = cv2.MORPH_CLOSE
    else:
        print("Morpho Operation not defined!")
        return None

    outImage = cv2.morphologyEx(binaryImage, op, morphKernel, None, None, opIterations, cv2.BORDER_REFLECT101)

    return outImage


# image path
path = "D://opencvImages//"
fileName = "backgroundTest.png"

# Reading an image in default mode:
inputImage = cv2.imread(path + fileName)

# (Optional) Deep copy for results:
inputImageCopy = inputImage.copy()

# Convert RGB to grayscale:
grayscaleImage = cv2.cvtColor(inputImage, cv2.COLOR_BGR2GRAY)

# Adaptive Thresholding
windowSize = 31
windowConstant = 11
binaryImage = cv2.adaptiveThreshold(grayscaleImage, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, windowSize,
                                    windowConstant)

# Apply a morphological closing with:
# Rectangular SE size 3 x 3 and 10 iterations
binaryImage = morphoOperation(binaryImage, 3, 10, "Closing")

# Find the EXTERNAL contours on the binary image:
contours, hierarchy = cv2.findContours(binaryImage, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# This list will store the target bounding box
maskRect = []

# Look for the outer bounding boxes (no children):
for i, c in enumerate(contours):

    # Get blob area:
    currentArea = cv2.contourArea(c)

    # Get the bounding rectangle:
    boundRect = cv2.boundingRect(c)

    # Set a minimum area
    minArea = 1000

    # Look for the target contour:
    if currentArea > minArea:
        # Found the target bounding rectangle:
        maskRect = boundRect

        # (Optional) Draw the rectangle on the input image:
        # Get the dimensions of the bounding rect:
        rectX = boundRect[0]
        rectY = boundRect[1]
        rectWidth = boundRect[2]
        rectHeight = boundRect[3]

        # (Optional) Set color and draw:
        color = (0, 0, 255)
        cv2.rectangle(inputImageCopy, (int(rectX), int(rectY)),
                      (int(rectX + rectWidth), int(rectY + rectHeight)), color, 2)

        # (Optional) Show image:
        showImage("Bounding Rectangle", inputImageCopy)

# Create mask for Grab n Cut,
# The mask is a uint8 type, same dimensions as
# original input:
mask = np.zeros(inputImage.shape[:2], np.uint8)

# Grab n Cut needs two empty matrices of
# Float type (64 bits) and size 1 (rows) x 65 (columns):
bgModel = np.zeros((1, 65), np.float64)
fgModel = np.zeros((1, 65), np.float64)

# Run Grab n Cut on INIT_WITH_RECT mode:
grabCutIterations = 5
mask, bgModel, fgModel = cv2.grabCut(inputImage, mask, maskRect, bgModel, fgModel, grabCutIterations,
                                     mode=cv2.GC_INIT_WITH_RECT)

# Set all definite background (0) and probable background pixels (2)
# to 0 while definite foreground and probable foreground pixels are
# set to 1
outputMask = np.where((mask == cv2.GC_BGD) | (mask == cv2.GC_PR_BGD), 0, 1)

# Scale the mask from the range [0, 1] to [0, 255]
outputMask = (outputMask * 255).astype("uint8")

# (Optional) Apply a morphological closing with:
# Rectangular SE size 3 x 3 and 5 iterations:
outputMask = morphoOperation(outputMask, 3, 5, "Closing")

# Apply a bitwise AND to the image using our mask generated by
# GrabCut to generate the final output image:
segmentedImage = cv2.bitwise_and(inputImage, inputImage, mask=outputMask)

showImage("Segmented Image", segmentedImage)
